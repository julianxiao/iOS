#include <stdio.h>
#include <stdlib.h>		// _MAX_PATH, exit()
#include <string.h>		// strcmp(), strlen(), strtok(), strcpy()
#include <math.h>
#include <time.h>

#include "ctype.h" // isspace()

#define LAYOUTENGINE_EXCEPTION	77		// exception handling
#define COMMAND_LINE ( 1 ) 
#define exitOrException(x) respondToExitOrException ( __FILE__, __LINE__, x )

//added by Jun
#define _MAX_PATH 255
#define _MAX_DRIVE 25
#define _MAX_DIR 255
#define _MAX_FNAME 255
#define _MAX_EXT 25

#ifdef __cplusplus
extern "C" {
#endif

void _splitpath ( const char* base_filename, char *drive, char* dir, char* fname, char* ext );
void _makepath ( char* pbook_filename, const char* fname);


void _set_iphone_path (const char *);
	void _BRIC_newpage(char *input, const char* pageid);
	void _BRIC_alternative(const char* pageid);
	void _BRIC_swap(const char* pageid, int index1, int index2);
	void _BRIC_replace(const char* pageid, int index, char *newPhoto);	
void testPbook();

struct color {
	double RED;		// each is in [0,255] with 255 being max of that color
	double GREEN;
	double BLUE;
};


struct config_params {
	// the output number is the number of layouts that are to be 
	// written as output; the working number is the depth of the layout list 
	// maintained during the layout creation process ... the deeper
	// the working layout list, the greater the computation requirement,
	// but the greater likelihood the search will yield better layouts; 
	//
	// the number of output layouts must be >= 1; and the number of working
	// layouts must be >= the number of output layouts
	int NUM_OUTPUT_LAYOUTS;
	int NUM_WORKING_LAYOUTS;

	// optimization is a subroutine that makes changes to the layout 
	// that increase the page layout score until a locally optimal layout 
	// has been obtained.  the search uses two 
	// elementary manipulations, "moves" and "trades"
	// 
	// this parameter must be non-negative
	//
	// in createPageList(), run optimizeLayout() only if number of GA's on page
	// is less than or equal to this value ... a value of 0 effectively turns off 
	// optimization, a very large value 
	// forces all pages to go through optimization regardless of number of images
	int OPTIMIZE_LAYOUT_PPP_THRESHOLD;

	// for page schedules that have a GA of type FIXED_DIM,
	// when generating alternate layouts, discard any pages 
	// where the region assigned to the FIXED_DIM GA is this small or smaller, 
	// compared to the target area 
	//
	// default value is 0.0, which corresponds to not weeding out anything
	//
	// only used if LAYOUT_ROTATION is set to one and other conditions are met;
	// see decideToDoLayoutRotation() for a complete specification
	double FIXED_DIM_DISCARD_THRESHOLD;

	// with layout rotation we rotate through layouts generated by createPage();
	// the layouts are generated by createAltPages()
	int LAYOUT_ROTATION;			// if this flag == 1 layout rotation is on and can happen
									// if this flag == 0 layout rotation is off
	int ROTATION_CAPACITY;			// number of layouts to rotate through; must be > 0
	int ROTATION_PPP_THRESHOLD;		// if number of photos in page schedule is <= this,
									// then layout rotation happens; must be >= 0

	// spacing between graphic elements, in inches
	double INTER_GA_SPACING;		// spacing between GAs 
	double PHOTO_SEQ_SPACING;		// spacing between photos in a photo sequence
	double PHOTO_GRP_SPACING;		// spacing between photos in a photo group

	// additional space around graphic element perimeters, also in inches
	double BORDER;

	// if this flag == 0, then respect aspects exactly
	// if this flag == 1, then alter aspect ratios within specified
	//		tolerance, to fill as much of the page as possible
	int RELAX_LAYOUT;

	// flag -- if 1, then transcribe and use any regions of interest specified 
	// in the input content file ... otherwise ignore 
	int USE_ROI;

	// flag -- if 1, then write image layout information to a text 
	// file; the text file contains a listing of the objects on each 
	// page, and for each object there is the position and size; 
	// if 0, do not output the text file
	int TXT_OUTPUT;

	// for output forms where numerical positions and dimensions
	// are reported (e.g. in the text file output if TXT_OUTPUT flag
	// is set to 1), distances are reported in units of dots 
	// at the specified dpi; that is, we take distances in inches and 
	// multiply by this number to get "distances in dpi" ... for example
	// a distance of 1.5 inches at 300 dpi is reported as 450.0
	double OUTPUT_DPI;

	// when this flag is set to 1, the program includes some sections of code 
	// originally written for algorithm testing
	int CAREFUL_MODE;

	double pageHeight;
	double pageWidth;
	double leftMargin;
	double rightMargin;
	double topMargin;
	double bottomMargin;
};


static double 	PHOTO_SEQ_SPACING_RATIO	= 3.0;	// ratio btwn INTER_GA_SPACING 
												// and PHOTO_SEQ_SPACING unless both values
												// are specified in config file
static double 	PHOTO_GRP_SPACING_RATIO	= 1.0;	// ratio btwn INTER_GA_SPACING 
												// and PHOTO_GRP_SPACING unless both values
												// are specified in config file
static double 	EPSILON				= 1e-9;

static double	PHOTO_TOO_BIG		= 4.0;	// must be in [1,Inf)
static double	PHOTO_WAY_TOO_BIG	= 8.0;	// must be in [1,Inf)
static double	PHOTO_TOO_SMALL		= 0.50;	// must be in [0,1]
static double	PHOTO_WAY_TOO_SMALL	= 0.25;	// must be in [0,1]

static double	FIXED_DIM_TOO_BIG		= 1.10;	// must be in [1,Inf)
static double	FIXED_DIM_WAY_TOO_BIG	= 1.20;	// must be in [1,Inf)
static double	FIXED_DIM_TOO_SMALL		= 0.98;	// must be in [0,1]
static double	FIXED_DIM_WAY_TOO_SMALL	= 0.95;	// must be in [0,1] */

const int		UNDEFINED_EXE_MODE	= -1;
const int		NEWPAGE				= 0;
const int		SWAP				= 1;
const int		CROP				= 2;
const int		SETBORDER			= 3;
const int		SETSPACING			= 4;
const int		REPLACE				= 6;
const int		SETMARGIN			= 7;
const int		SETBSM				= 8;
const int		DIFFERENTPAGE		= 9;
const int		SETDIMENSIONS		= 10;
const int		NO_TYPE				= 0;
const int		PHOTO				= 1;
const int		PHOTO_SEQ			= 2;	// photo sequence (as video keyframes)
const int		PHOTO_VER			= 3;	// photo versions (select one version for layout)
const int		PHOTO_GRP			= 4;	// photo group (each presentation shows all photos)
const int		FIXED_DIM			= 5;	// versions(s) of blocks having fixed dimension(s)
const int		NO_INDEX			= -1;
const int		MOVE				= 1;
const int		TRADE				= 2;
const int		HORIZ_AND_VERT		= 2;
const int		VERT				= 1;
const int		HORIZ				= 0;
const int		PASS				= 1;
const int		FAIL				= 0;
const int		PAGES_TREE			= 1;	// object number of pages tree - reserved as 1
const int		MAX_OBJECTS			= 8192;

static double	BEST_LAYOUT_SCORE	= 0.0;

static unsigned long pseudorandom_val = 0;	// storage for pseudorandom seqeunce*/
const unsigned long	rand_m = 139968;
const unsigned long	rand_a = 205;
const unsigned long	rand_c = 29573;

struct point_in_plane {
	double x;
	double y;
};

struct path {
	int dir;		// either HORIZ or VERT

	int num_steps;	// includes values of both interior and terminal nodes
	int *nodes; 	// actual sequence of node values 

	double fixed_dist;		// distance along path that is fixed 
							// (gutters, borders, photos of fixed size)
	double var_dist_term;	// used to compute dist along path that is variable
};

struct path_collection {
	int num_paths_HORIZ;	// path across (say, from left to right)
	int num_paths_VERT;		// path up or down (say, from bottom to top)
	struct path *paths;		// the array of the paths themselves
};

struct subT_identifier {	// subTree identifier
	int GA_index;			// index of assembly the subTree belongs to
	int subT_index;			// index of the subTree inside its assembly
};

struct GE_identifier {		// graphic element identifier
	int GA_index;			// index of assembly the element belongs to
	int GE_index;			// index of the element inside its assembly
};

struct GE_identifier_list {
	int num_GEIDs;
	struct GE_identifier *GEIDs;
};

struct pixel_rectangle {	// a rectangular subset of a digital photo
	int height;				// units of pixels
	int width;
	int vert_offset;
	int horiz_offset;
};

struct physical_rectangle {		// a rectangular subset of a digital photo
	double height;			// units of pixels
	double width;
	double vert_offset;
	double horiz_offset;
};

struct integer_list {
	int num_integers;
	int *integers;
};

struct twoD_integer_array {
	int num_integer_lists;
	struct integer_list *integer_lists;
};

struct double_list {
	int num_doubles;
	double *doubles;
};

struct twoD_double_array {
	int num_double_lists;
	struct double_list *double_lists;
};

struct fixed_dimensions_version {	// a block with fixed dimensions in units of inches
	struct GE_identifier GE_ID;
	double height;
	double width;
};

struct fixed_dimensions {	// a GA with at least one version, each having a unique 
	int num_fd_versions;		// aspect (within the GA), and known fixed dimensions
	struct fixed_dimensions_version *fd_versions;
};

struct photo {				// type structure for "photo" graphic image
	struct GE_identifier GE_ID;
	char *filename;			// photo filename
	int height;				// height of digital image in units of pixels
	int width;				// width of digital image in units of pixels

	// subset of photo remaining after a crop
	int has_crop_region;
	struct pixel_rectangle crop_region;

	// subset of photo that is a region of interest 
	//
	// this is expressed relative to the photo dimensions; 
	// but if photo "has_crop_region,"
	// the ROI should fit inside the crop_region,
	int has_ROI;
	struct pixel_rectangle ROI;
};

struct row_col_config {
	int num_rows;
	int num_cols;
};

struct photo_seq {
	int num_photos;			// number of photos in photo sequence
	struct photo *photos;	// photos in the sequence 

	int num_rc_cfgs;				// arrangements of rows and columns in which
	struct row_col_config *rc_cfgs;	// the photos can be arranged
};

struct photo_grp_photo {
	int photo_GA_index;			// the GA_index of the corresponding GA of type PHOTO
	struct GE_identifier GE_ID;	// for referring to photo in context of this photo group
};

struct photo_grp {
	int num_photos;			// number of photos in photo group
	struct photo_grp_photo *photo_grp_photos;
};

struct photo_ver {
	int num_versions;		// number of photo versions or alternatives
	struct photo *photos;	// the actual photos 
};

struct graphic_assembly {
	int GA_index;				// index of this assembly in the GA_list 
	int type;					// one of PHOTO, PHOTO_SEQ, PHOTO_VER, PHOTO_GRP

	struct photo ph;			// only one should be in use
	struct photo_grp ph_grp;
	struct photo_ver ph_ver;
	struct fixed_dimensions fd;
	struct photo_seq ph_seq;

	int num_subTs;				// # arrangements (sublayouts) of the graphic elements
	struct GE_treeNode **subTs;	// the actual arrangements (sublayouts)
};

struct graphic_assembly_list {
	int num_GAs;						// # of graphic assemblies
	struct graphic_assembly *GA;		// ordered array of graphic assemblies
};

struct GE_treeNode {	// tree whose terminal nodes are graphic elements

	int value;			// tree nodes can be addressed using this number
						// terminal nodes have positive values, interior nodes do not

	int parent;			// value for parent
	int Lchild;			// value for the left child
	int Rchild;			// value for the right child

	int cut_dir;		// if node is not a leaf, cut direction 
	double cut_spacing;	// if node is not a leaf, (min) dist between GEs separated by cut

	double border;		// additional perimeter space around GE

	struct GE_identifier GE_ID;	// if node is a leaf, the GE_ID of the content
	int GA_index;		// if node is part of a GA, the GA_index it is associated with
						// (content/leaf OR internal cut), otherwise -1 (invalid GA_index)

	double bb_a;		// scratch space holding aspect of bounding box
	double bb_e;		// scratch space holding (relative) area of bounding box
};

struct subT_treeNode {	// tree whose terminal nodes are subTs of graphic assemblies

	int value;			// tree nodes can be addressed using this number
						// terminal nodes have positive values, interior nodes do not

	int parent;			// value for parent
	int Lchild;			// value for the left child
	int Rchild;			// value for the right child

	int cut_dir;		// if node is not a leaf, cut direction 
	struct subT_identifier subT_ID; // if node is leaf, identify which subT of which GA
};

struct potential_move {
	int is_allowed;
	int subT_index;			// subT_index to use when inserting GA into dest tree
	int node_index;			// node in dest tree (AFTER GA is removed 
							// from its current position in the source page 
							// (this is only relevant if the source page is 
							// the same as the destination page))
	int cut_dir;			// cut direction to add when inserting GA into 
							// dest tree
	double score_change;
};

struct potential_trade {
	int is_allowed;
	int subT_index;			// subT to use when inserting GA into dest page
	int node_index;			// node where GA will be placed in dest tree 
							// (AFTER exchange GA is removed from its position
							// in dest tree)
	int cut_dir;			// cut direction to add when inserting GA into 
							// dest tree
	struct subT_identifier exch_subT_ID;	// the ID of the subtree of the GA 
							// to be traded back and placed in the source tree
	int exch_node_index;	// node where exchange GA will be placed 
							// in the source tree (AFTER GA is removed)
	int exch_cut_dir;		// cut direction to add when inserting exchange 
							// GA into source tree
	int this_GA_first;		// if 1, then the current GA will be placed in 
							// dest tree, then exchange GA will be placed  
							// in source tree; if 0, then exchange GA is 
							// placed first ... this is only relevant if source 
							// page and dest page are the same
	double score_change;
};

struct change_book_entry {
	struct subT_identifier subT_ID;	// ID of subTree in use ... includes the GA_index, 
									// as well as the subT_index currently in use

	// (1) whether moving this GA is allowed, given conditions 
	// in the current pbook; (2) details of how the move would 
	// be executed; and (3) the resulting net change in score 
	struct potential_move pmv;

	// (1) whether trading this GA is allowed, given conditions 
	// in the current pbook; (2) how the trade would be executed,
	// and (3) the resulting net change in score
	struct potential_trade ptd;
};

struct change_spec {
	int change_pending;				// 0 (if no change pending), or MOVE or TRADE
	struct change_book_entry cbe;	// a copy of the first cbe affected by the change
};

struct change_book {
	// one change book entry for each GA
	int num_GAs;
	struct change_book_entry *cbe;
};

struct collection_schedule_spec {
	int num_items;		// number of GA's plus number of forced page breaks
	int *items;			// each "item" is either a GA_index, 
						// or a flag indicating a forced page break;
						// the first and last items must not be page breaks;
						// not allowed to have two consecutive page breaks
};

struct graphic_element_schedule {
	struct GE_identifier GE_ID;	// allows us to retrieve the relative area value (if any)
								// from the content file transcript (if any)
	double relative_area;		// area value ... if GE is not part of a fixed-dimensions GA, 
								// this is a relative area proportion; 
								// otherwise it is an absolute area in square inches
	double target_area;			// target area of this GE on this page, 
								// estimated before layout is generated
};

struct page_schedule_entry {
	// here we record one GA_index; 
	// the number of GE's that could be part of any presentation of the GA;
	// and for each GE, the GE_ID and a relative area proportion;
	//
	// during generation of a layout for a specific page, 
	// for each GE here we record also a target area
	int GA_index;
	int num_GEs;
	struct graphic_element_schedule *GE_scheds;
};

struct page_schedule {
	// sequence of GA's scheduled to appear on the page;
	// one page schedule entry for each GA
	int num_GAs;
	struct page_schedule_entry *pse;
};

struct collection_schedule {
	int num_pages;				// number of pages
	struct page_schedule *pg_scheds;
};

struct viewport {
	struct GE_identifier GE_ID;				// GE assigned to viewport
	struct physical_rectangle p_rect;		// region on the page where photo content can be visible
	struct pixel_rectangle v_rect;			// portion of GE visible through hole (if GE is photo )
};

struct layout {
	int num_VPs;							// number of viewports in the layout
	struct viewport *VPs;
	double score;							// total or combined score of layout
};

struct pbook_page {
	int num_GAs;					// # of GA's in the page tree 
	struct subT_treeNode *page_T;	// "coarse" tree whose leaves are subTs of GAs
	struct layout page_L;
	double usable_height;			// height of usable region (in units of inches)
	double usable_width;			// width of usable region (in units of inches)

	struct page_schedule sched;		// the graphic assemblies on this page
	int rotation_count;
};

struct pbook_chapter {
	int num_GAs;
	int num_pages;
	int min_GApp;			// min graphic assemblies per page in this chapter
	int max_GApp;			// max graphic assemblies per page in this chapter
	struct pbook_page *pages;
};

struct pbook {
	int num_GAs;
	int num_pages;
	int num_chapters;
	struct pbook_chapter *chapters;
};

struct page_list {
	int num_pages;
	struct pbook_page *pages;
};

struct page_list_sequence {
	int num_page_lists;
	struct page_list **page_lists;
};

struct page_sequence {
	int num_pages;
	struct pbook_page **pages;	// an array of pointers to pbook_page
};

struct photo_spec {
	struct GE_identifier GE_ID;
	char *filename;
	int pixel_height;	// in units of pixels
	int pixel_width;	// in units of pixels

	int has_crop_region;// 1 if so, 0 if not 
	struct pixel_rectangle crop_region;

	int has_ROI;		// 1 if so, 0 if not 
	struct pixel_rectangle ROI;

	double area;		// a relative area proportion, or an area; must be positive 
};

struct photo_grp_spec {
	int num_photo_specs;// must be positive
	struct photo_spec *ph_specs;
};

struct photo_ver_spec {
	int num_photo_specs;// must be positive
	struct photo_spec *ph_specs;

	// the supplied area value will be assigned to each version 
	double area;
};

struct fixed_dimensions_version_spec {
	struct GE_identifier GE_ID;
	double height;		// must be positive
	double width;		// must be positive
};

struct fixed_dimensions_spec {
	int num_fd_version_specs;	// must be positive
	struct fixed_dimensions_version_spec *fd_version_specs;
};

struct photo_seq_spec {
	int num_photo_specs;// must be positive
	struct photo_spec *ph_specs;

	// area value will be divided among all the photos in the sequence, 
	// ignoring gutters and borders between the photos
	double area;
};

struct graphic_assembly_spec {
	int GA_index;
	int type;

	struct photo_spec ph_spec;		// only one of these should be in use
	struct photo_grp_spec ph_grp_spec;
	struct photo_ver_spec ph_ver_spec;
	struct photo_seq_spec ph_seq_spec;
	struct fixed_dimensions_spec fd_spec;
};

struct content_file_transcript {
	int num_items;		// # of graphic assemblies
	struct graphic_assembly_spec *GA_specs;
};


void respondToExitOrException ( const char* filename, int line_number, 
								const char* description );

/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
////  FUNCTION PROTOTYPES THAT CONTRIBUTE TO THE API
/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
void runReplace ( char *state_file, struct content_file_transcript *cft,
				  int leaving_GA_index );
void runSetDimensions ( char *state_file, int GA_index, double height, double width );
void runSetBSM ( char *state_file, double border, double spacing, 
				 double leftMargin, double rightMargin, 
				 double topMargin, double bottomMargin );
void runSetMargin ( char *state_file, double leftMargin, double rightMargin, 
					double topMargin, double bottomMargin );
void runSetSpacing ( char *state_file, double spacing );
void runSetBorder ( char *state_file, double border );
void runCrop ( char *state_file, int GA_index, 
			   int height, int width, int vert_offset, int horiz_offset );
void runSwap ( char *state_file, int GA_index_1, int GA_index_2 );
void runNewPage ( struct config_params *cp, struct content_file_transcript *cft, 
				  char *outfile );
void runDifferentPage ( char *state_file );
void setConfigDefaults ( struct config_params *cp );
/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
int replaceGA ( struct config_params *cp, struct pbook_page *page,
				int leaving_GA_index, int incoming_GA_index, 
				struct graphic_assembly_list *GA_list );
int setMarginOnPage ( struct config_params *cp, struct pbook_page *page, 
					  struct graphic_assembly_list *GA_list );
int setSpacingOnPage ( struct config_params *cp, struct pbook_page *page, 
			 		   double spacing, struct graphic_assembly_list *GA_list );
int setBorderOnPage ( struct config_params *cp, struct pbook_page *page, 
			 		  double border, struct graphic_assembly_list *GA_list );
int cropPhotoOnPage ( struct config_params *cp, struct pbook_page *page, int GA_index, 
					  int height, int width, int vert_offset, int horiz_offset,
					  struct graphic_assembly_list *GA_list );
void removeGAFromPageSchedule ( int GA_index, struct page_schedule *pg_sched );
void addGAToPageSchedule ( struct graphic_assembly *GA, 
						   struct page_schedule *pg_sched );
void resetSublayoutSpacingValues ( struct config_params *cp,
								   struct graphic_assembly_list *GA_list );
struct page_list *createAltPages ( struct config_params *cp, 
								   struct graphic_assembly_list *GA_list, 
								   struct page_schedule *input_pg_sched, 
								   int num_alts );
void reflectPageTopToBottom ( struct config_params *cp, struct pbook_page *page );
void reflectPageLeftToRight ( struct config_params *cp, struct pbook_page *page );
struct page_list *createPageList ( struct config_params *cp, 
								   struct graphic_assembly_list *GA_list, 
								   struct page_schedule *pg_sched );
struct page_list *createPage ( struct config_params *cp, 
							   struct graphic_assembly_list *GA_list, 
							   struct page_schedule *pg_sched,
							   int input_counter );
void initPageSchedule ( struct page_schedule *pg_sched, int num_GAs );
void writeOutput ( struct config_params *cp, struct page_list_sequence *pls, 
				   struct graphic_assembly_list *GA_list, char *base_filename );
int reflowPage ( struct config_params *cp, struct pbook_page *page, bool iterate_GA_presentations, struct graphic_assembly_list *GA_list );
int setDimensions ( struct config_params *cp, struct pbook_page *page, 
					int GA_index, double height, double width,
					struct graphic_assembly_list *GA_list );
int swapGAs ( struct config_params *cp, struct pbook_page *page, 
			  int GA_index_1, int GA_index_2,
			  struct graphic_assembly_list *GA_list );
void deletePageList ( struct config_params *cp, struct page_list *pg_list );
	
	
// added by Jun Xiao

	
#ifdef __cplusplus
	}
#endif
		
